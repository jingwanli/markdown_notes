###Day 06 面向对象

类的成员属性默认初始值：

int		0

float	0.0f

double	0.0

char	''

String	null

引用类型	null

对象一旦创建，对象的成员变量就会分配默认的初始值

需求：

使用java描述一个车与修车厂两个事物，车具备的公共属性：轮子数、名字，颜色，还具备跑得功能，

跑前检测轮子数是否少于4个，若小于4个，则送修。

修车厂：具备的公共属性：名字，地址，电话  公共的行为：修车

初学者容易犯的错误：

1).不在同一个范围内，随意的引用了变量。

​    变量在同一个作用域（大括号）是可以直接访问的。

2)如果一个类要访问另外一个变量时，那么这时候就只能通过创建对象进行访问(仅对目前正确)。

成员变量与局部变量的区别：

\1. 定义的位置区别：1）成员变量是定义在方法之外，类之内的

​     2）局部变量定义在方法之内。

2.作用上的区别：1）成员变量的作用是用于描述一类事物的公共属性的

2）局部变量的作用就是提供一个变量给方法内部使用而已

3.生命周期区别：1）成员变量随着对象的创建而存在，随着对象的消失而消失

 2）局部变量在调用了对应的方法，执行到了创建该变量的语句时存在，

​       局部变量一旦出了自己的作用域那么马上从内存中消失

4.初始值的区别：1）成员标量是有默认的初始值的。

2）局部变量没有默认的初始值，必须先初始化才能使用。

匿名对象

对匿名对象不赋予属性值，因为永远访问不到。

应用场景：1）如果一个对象需要调用一个方法，而调用完后就不再使用，可以使用匿名对象。

  2）可以作为实参调用一个函数。

 

权限修饰符：控制变量的可见范围。

封装的步骤：

1）使用private修饰需要被封装的属性。

2）提供一个公共的方法设置或者获取该私有的成员属性。

命名规范：set属性名（）； get属性名（）；

 Question:封装一定要提供get或者set方法吗？ 不一定，根据需求而定。

在现实开发中，一般实体类的所有成员属性（成员标量）都要封装起来。

实体类：用于描述一类事物的类

工具类（如Array数组的工具类）

封装的好处：

1）提高数据的安全性

2）操作简单（相对调用者而言）

3）隐藏了实现

需求：使用java类描述一个计算器类，计算器具备操作数1，操作数2，操作符三个公共属性，还具备计算的功能行为。

要求：不能直接对操作数1，操作数2，运算符这些属性进行直接的赋值，要封装起来（+ - * /）

//Tip：如果是字符串比较相等，用equals。如果是字符（基本数据类型），用==即可。

需要提供set方法，因为用户不关心刚输入了什么，故可以不提供get方法。

class Calculator{

private int num1;

private int num2;

private char option; //运算符

//set()...或者

public void initCalculator(int n1,int n2,char o){ //不需要判断类型，前面的类型符限定了

num1 = n1;

num2 = n2;

if( o=='+' || o == '-' || o == '*'|| o=='/'){

option = o;

}else{

option = '+';

}

public void calculate(){

switch(option){

case '+':

System.out.println("做加法运算，结果是：" + (num1+num2));

break;

case '-':

System.out.println("做减法运算，结果是：" + (num1-num2));

break;

case '*':

System.out.println("做乘法运算，结果是："+ (num1*num2));

break;

case '/':

System.out.println("做除法运算，结果是："+ (num1/num2)); 

break;

}

}

}

class Demo6{

public static void main(String[] args){

Calculator c = new Calculator();

c.initCalculator(1,2,'*');

c.calculate();

}

 }

需求：目前存在数组：int[] arr = {0,0,12,1,0,4,6,0},编写一个函数，接收该数组然后把该数组的0清空，然后返回

​    一个不存在0元素的数组。

步骤；1.计算新数组的长度  原来的数组长度-0的个数

​    2.

###Day07 构造函数与static修饰符

---------------------------------复习--------------------------------

java面向对象语言：

核心思想：找适合的对象做适合的事情

创建对象时，如果没有显示的调用构造方法，java编译器在编译的时候加上一个默认的无餐构造方法。

 java编译器和JVM是两个不同的程序。.class文件是编译器给JVM用的，如果想看到.class中的内容，需要反编译。

jdk反编译工具：javap.exe  命令行界面直接输入javap 可以看到帮助文档

javap -c -l -private  类名

   -反编译 -显示行号 -显示类的所有成员

java编译器添加的无参构造方法的权限是：与类的权限修饰符是一致的！

构造函数是可以在一个类中以函数重载的形式存在多个的！

构造函数

构造函数与普通函数的区别：

1.返回值类型的区别；

2.函数名的区别

3.调用方式的区别 1）构造函数是在创建对象时 由jvm调用的

 2）普通函数时使用时调用的，一个对象可以多次调用普通函数

4.作用上的区别：1）构造函数的作用用于初始化一个对象

2）普通函数是用于描述一类事物的公共行为的。

 

构造函数：给对应的对象初始化。

构造代码块：

作用：给对象进行统一的初始化。（可以减少重复代码）

格式：{

构造代码块；

​    }

注意：构造代码块必须位于成员变量位置上！

代码块的类别：1）构造代码块

​    2）局部代码块：大括号位于方法之内

作用：缩短局部变量的生命周期，减少一点内存（实际生产中基本不用）

​    3）静态代码块

注意：1. java编译器编译一个java源文件的时候，会把成员变量的声明(只是声明)提至一个类的最前端

​    2.成员变量的初始化工作其实都是在构造函数中执行的。

​    3.一旦经过java的编译器编译以后，构造代码块的代码就会被移动到构造函数中执行，构造函数(最后执行）中的代码是

最后执行的。

​    4.成员变量的显示初始化与构造代码块 的代码是按照代码的顺序执行的。

tip：构造函数里可以调用类的方法！可以想象成员方法都在类里，而不是对象里。在构造方法连普通的成员变量都可以调用。。

this关键字

​    如果存在同名的成员变量与局部变量时，在方法的内部访问的是局部变量（就近原则）

​    注意：一个方法要运行的时候，jvm会在栈内存中开辟一片属于这个方法的空间，让这个方法在这片空间内执行。

   

this关键字：代表了所属函数的调用者对象。

this关键字的作用：

1）如果存在同名成员变量与局部变量时，在方法内部默认的是访问局部变量的数据。

可以通过this关键字指定访问成员变量的数据。

2）如果在一个方法中访问一个变量，该变量只存在成员变量的情况下，那么java编译器会在该变量

的前面添加this关键字

3）在一个构造函数中，可以调用另外一个构造函数 初始化对象；this(name); //一个参数的

注意：一个函数的形式参数也是属于局部变量。存在同名的成员变量与局部变量，在方法内部默认

​     是使用局部变量的。

​     this关键字调用其他的构造函数要注意的事项：

1）this关键字调用其他的构造函数时，this关键字必须要位于构造函数的第一个语句 this(name);

2）this关键字在构造函数中不能出现互相调用的情况，因为是一个死循环

static关键字

![img](//note.youdao.com/src/WEBRESOURCE0802b2330e0ababde72ab4190707ffa6)

static修饰的静态成员变量只会在数据共享区中维护一份，而非静态成员变量会在每个对象中都维护一份。

1.static修饰成员变量 

如果有数据需要被共享给所有对象使用时，那么就可以使用static修饰。

静态成员变量的访问方式：

1）使用对象访问：对象.变量名

2）可以使用类名进行访问：类名.变量名

 注意：1）非静态的成员变量只能使用对象进行访问，不能使用类名进行访问！

​     2）千万不要为了方便访问数据而使用static修饰成员变量，只有成员变量的数据是真正需要被共享的时候，才使用static修饰。

 

\2. static修饰成员函数 

###Day08

static修饰方法：

访问方式： 1. 使用对象进行访问

​     \2. 类名.静态函数名字

推荐使用类名直接访问静态的成员。why？方便，节省内存  

静态函数要注意的事项：

1.静态函数可以调用类名，或者对象进行调用，而非静态函数只能使用对象进行调用

2.静态的函数可以直接访问静态的成员，但是不能直接访问非静态的成员。静态函数可以访问非静态方法。

因为静态函数是可以使用类名直接调用的，这时候可能还没有存在对象，而非静态的成员数据是随着对象的存在而存在

3.非静态函数是可以直接访问静态与非静态的成员。

 因为非静态的函数只能使用对象调用。当对象存在时，静态数据已经存在。

\4. 静态函数不能出现this或者super关键字。

因为静态函数时可以使用类名.调用的，一旦使用类名调用这时候不存在对象，而this关键字代表了一个函数的

调用者对象，这时候产生了冲突。

​      静态的数据的生命周期：静态的成员变量数据是优先于对象存在的！

​      静态方法与非 静态方法的字节码文件是同时存在内存中的，只是静态的成员变量数据是优先于对象存在而已！

（方法只是存了一份代码即字节码而已，不调用时不会执行的）

​     硬盘中：

​    Demo2.class

​    Student.class

 一个类文件是在要使用到的时候才会被加载到内存中的（懒惰型加载）。而静态代码块是在类文件加载的时候执行的！

main方法存在方法区的时候仅仅是一段代码而已。  

![](/Users/lijingwan/Documents/img/java-1.png)  

方法执行完毕后，所占用的栈内存会马上释放。

但是，.class文件会一直存在于方法区，当程序不结束，不会重新加载class文件（只加载一次）

###Main方法详解

> static 什么时候修饰一个函数？

​	如果一个函数没有==直接==访问到非静态的成员时，那么就可以使用static修饰了。

​		一般用于工具类的方法。

​	静态函数不能访问非静态成员？错

​	静态函数里可以有对象（间接）

#### 案例

​	编写一个数组的工具类  Array.toString()  sort()

```java
package day07;

class ArrayTool{
	public static String toString(int[] arr) {
		String result = "";
		for(int i=0;i<arr.length;i++) {
			if(i==0) {
				result +="["+ arr[0] + ",";
			}else if(i == arr.length-1) {
				result += arr[i] + "]";
			}else {
				result += arr[i] +",";
			}
		}
		return result;
	}
	
	public static void sort(int[] arr) {
		for(int i = 0; i<arr.length;i++) {
			for(int j=i+1;j<arr.length;j++) {
				if(arr[i]>arr[j]) {
					int temp = arr[i];
					arr[i] = arr[j];
					arr[j] = temp;
				}
			}
		}
	}
}


public class Demo1 {

	public static void main(String[] args) {
		int[] arr = {12,1,456,165};
		ArrayTool.sort(arr);
		String info = ArrayTool.toString(arr);
		System.out.println("数组的元素：" + info);
		
	}

} 
```

> 静态成员变量与非静态成员变量的区别

 	1. 作用上的区别
     - 静态成员变量的作用共享一个数据给所有的对象使用
     - 非静态的成员变量的作用是描述一类事物的公共属性
	2. 数量与存储位置上的区别
    - 静态成员变量是存储方法区内存中，而且只会存在一份数据
    - 非静态的成员变量是存储在内存中，有n个对象就有n份数据
    3. 生命周期的区别
    - 静态的成员变量数据是随着类的加载而存在，随着类文件的消失而消失
    - 非静态的成员数据是随着对象的创建而存在，随着对象被垃圾回收器回收而消失

> main函数详解：

1. public	JAVA虚拟机也是一个程序，权限是最大，在任何情况下都可以访问。

2. static      静态可以让jvm调用main函数的时候更加的方便，不需要通过对象调用。

   ​		不使用static修饰的缺点：需要创建对象调用。 

   ​							     jvm不知道如何创建对象，因为创建对象有些是要有参数的。

3. void        因为返回的数据是给jvm，jvm使用这个数据是没有意义的。

4. main       函数名。注意：main不是关键字，只不过是jvm能识别的一个特殊函数名而已

5. arguments     担心某些程序在启动时需要参数 （不过现在一般使用scanner）

### 单例设计模式：

> 模式：模式就是解决一类问题的固定步骤

> 单例设计模式：保证一个类在==内存==中只有一个对象

##### 分类：

> 饿汉式

1. 私有化构造函数
2. 声明本类的引用类型变量，并且使用该变量指向本类对象
3. 提供一个公共静态的方法获取本类的对象

```java
//饿汉式
package day07;

//自己的代码部分
class Single{

    private static Single s = new Single();
    private Single() { }
    public static Single getInstance() {
        return s;
    }
}

//别人的代码部分
public class Demo2 {

    public static void main(String[] args) {

        Single s1 = Single.getInstance();
        Single s2 = Single.getInstance();
        System.out.println(s1==s2);
    }

}

```

> 懒汉式

1. 私有化构造函数

2. 声明本类的引用类型变量，但是不要创建对象

3. 提供公共静态方法获取本类的对象，获取之前先判断是否已经创建了本类对象

   如果已经创建了，那么直接返回对象即可，如果没有创建，先创建本类的对象再返回。

```java
package day07;

class Single2{
	
	private static Single2 s;
	private Single2() {}
	public static Single2 getInstance() {
		if(s==null) {
			s = new Single2();
		}
		return s;
	}
}

public class Demo3 {
	
	public static void main(String[] args) {
		Single2 s1 = Single2.getInstance();
		Single2 s2 = Single2.getInstance();
		System.out.println(s1==s2);
	}

}
```

推荐使用：饿汉式。 因为懒汉单例设计模式会存在线程安全问题，目前还不能保证一个类在内存中

只有一个对象。